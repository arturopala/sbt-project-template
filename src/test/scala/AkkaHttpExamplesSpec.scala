import org.scalatest.{ WordSpecLike, Matchers }
import org.scalatest.prop.PropertyChecks
import org.scalatest.junit.JUnitRunner
import org.scalacheck._
import akka.http.scaladsl.testkit.ScalatestRouteTest
import akka.http.scaladsl.model.StatusCodes
import org.scalatest.matchers._

class ExampleAkkaHttpSpec extends WordSpecLike with Matchers with PropertyChecks with ScalatestRouteTest {

  implicit override val generatorDrivenConfig = PropertyCheckConfig(minSize = 1, maxSize = 100, minSuccessful = 100, workers = 5)

  import AkkaHttpExamples.http.incoming.highlevel.directives._
  import akka.http.scaladsl.server._
  import akka.http.scaladsl.model.headers._

  object CustomMatchers {

    import akka.http.scaladsl.model._

    class ContentEncodingMatcher(expectedEncoding: HttpEncoding) extends Matcher[HttpResponse] {
      def apply(left: HttpResponse) = {
        val encoding = left.encoding
        MatchResult(
          encoding == expectedEncoding,
          s"""Encoding $encoding is not $expectedEncoding""",
          s"""Encoding $encoding is $expectedEncoding"""
        )
      }
    }

    def haveContentEncoding(expectedEncoding: HttpEncoding) = new ContentEncodingMatcher(expectedEncoding)
  }

  import CustomMatchers._

  "An Akka Http" must {
    "provide directives" which {

      "cancelRejection: cancels rejection" in {
        Get("/") ~> route9 ~> check {
          rejections shouldEqual Nil
          handled shouldEqual false
        }
      }

      "cancelRejections: cancels rejections" in {
        Get("/") ~> route10 ~> check {
          rejections shouldEqual Nil
          handled shouldEqual false
        }
      }

      "extract: extracts value from the request context" in {
        Get("/abcdef") ~> route11 ~> check {
          responseAs[String] shouldEqual "The length of the request URI is 25"
        }
      }

      "extractRequest: extracts the complete HttpRequest instance" in {
        Post("/", "text") ~> route12 ~> check {
          responseAs[String] shouldEqual "Request method is POST and content-type is text/plain; charset=UTF-8"
        }
        Get("/") ~> route12 ~> check {
          responseAs[String] shouldEqual "Request method is GET and content-type is none/none"
        }
      }

      "extractUnmatchedPath: extracts the unmatched path from the request context" in {
        Get("/abc") ~> route13 ~> check {
          responseAs[String] shouldEqual "Unmatched: ''"
        }
        Get("/abc/456") ~> route13 ~> check {
          responseAs[String] shouldEqual "Unmatched: '/456'"
        }
      }

      "extractUri: accesses the full URI of the request" in {
        Get("/") ~> route14 ~> check {
          // tests are executed with the host assumed to be "example.com"
          responseAs[String] shouldEqual "Full URI: http://example.com/"
        }
        Get("/test") ~> route14 ~> check {
          responseAs[String] shouldEqual "Full URI: http://example.com/test"
        }
      }

      "mapInnerRoute: changes the execution model of the inner route by wrapping it with arbitrary logic" in {
        Get("/") ~> route15 ~> check {
          responseAs[String] shouldEqual "Got IllegalArgumentException 'BLIP! BLOP! Everything broke'"
        }
      }

      "mapRejections: transforms the list of rejections the inner route produced" in {
        Get("/") ~> route16 ~> check {
          rejection shouldEqual AuthorizationFailedRejection
        }
      }

      "mapRequest: transforms the request before it is handled by the inner route" in {
        Get("/") ~> route17 ~> check {
          responseAs[String] shouldEqual "The request method was POST"
        }
      }

      "mapRequestContext: transforms the RequestContext before it is passed to the inner route" in {
        Get("/abc/def/ghi") ~> route18 ~> check {
          responseAs[String] shouldEqual "POST"
        }
      }

      "mapResponse: changes the response that was generated by the inner route" in {
        Get("/abcdef?ghi=12") ~> route19 ~> check {
          status shouldEqual StatusCodes.BadGateway
        }
      }

      "mapResponseEntity: changes the response entity that was generated by the inner route" in {
        Get("/") ~> route20 ~> check {
          responseAs[String] shouldEqual "testabc"
        }
      }

      "mapResponseHeaders: changes the list of response headers that was generated by the inner route" in {
        Get("/") ~> RawHeader("id", "12345") ~> RawHeader("id2", "67890") ~> route21 ~> check {
          header("id") shouldEqual None
          header("id2").get.value shouldEqual "67890"
        }
      }

      "mapRouteResultPF: changes the message the inner route sends to the responder" in {
        Get("/") ~> route22 ~> check {
          rejection shouldEqual AuthorizationFailedRejection
        }
      }

      "mapUnmatchedPath: transforms the unmatchedPath field of the request context for inner routes" in {
        Get("/123/abc") ~> route23 ~> check {
          responseAs[String] shouldEqual "Content"
        }
        Get("/123456/abc") ~> route23 ~> check {
          responseAs[String] shouldEqual "Content"
        }
      }

      "provide: passes the request unchanged to its inner route" in {
        Get("/") ~> route24 ~> check {
          responseAs[String] shouldEqual "prefix:test"
        }
      }

      "textract: calculates a tuple of values from the request context and provides them to the inner route" in {
        Get("/abcdef?ghi=12") ~> route25 ~> check {
          responseAs[String] shouldEqual "The path is /abcdef and the query is ghi=12"
        }
      }

      "tprovide: provides a tuple of values to the inner route" in {
        Get("/") ~> route26 ~> check {
          responseAs[String] shouldEqual "Value is test and its length is 4"
        }
      }

      "conditional: provides a tuple of values to the inner route" in {
        Get("/") ~> RawHeader("ETag", "aaa") ~> route27 ~> check {
          status === StatusCodes.NotModified
        }
        Get("/") ~> route27 ~> check {
          status === StatusCodes.OK
        }
      }

      "decodeRequest: tries to decode the request with the specified Decoder or rejects" in {
        import akka.http.scaladsl.coding._
        val helloGzipped = Gzip.encode(akka.util.ByteString("Hello"));
        val helloDeflated = Deflate.encode(akka.util.ByteString("Hello"));

        Post("/", helloGzipped) ~> `Content-Encoding`(HttpEncodings.gzip) ~> route28 ~> check {
          responseAs[String] shouldEqual "Request content: 'Hello'"
        }
        Post("/", helloDeflated) ~> `Content-Encoding`(HttpEncodings.deflate) ~> route28 ~> check {
          responseAs[String] shouldEqual "Request content: 'Hello'"
        }
        Post("/", "hello uncompressed") ~> `Content-Encoding`(HttpEncodings.identity) ~> route28 ~> check {
          responseAs[String] shouldEqual "Request content: 'hello uncompressed'"
        }
      }

      "decodeRequestWith: tries to decode the request with the specified Decoder or rejects" in {
        import akka.http.scaladsl.coding._
        val helloGzipped = Gzip.encode(akka.util.ByteString("Hello"));
        val helloDeflated = Deflate.encode(akka.util.ByteString("Hello"));

        Post("/", helloGzipped) ~> `Content-Encoding`(HttpEncodings.gzip) ~> route28a ~> check {
          responseAs[String] shouldEqual "Request content: 'Hello'"
        }
        Post("/", helloDeflated) ~> `Content-Encoding`(HttpEncodings.deflate) ~> route28a ~> check {
          rejection shouldEqual UnsupportedRequestEncodingRejection(HttpEncodings.gzip)
        }
        Post("/", "hello") ~> `Content-Encoding`(HttpEncodings.identity) ~> route28a ~> check {
          rejection shouldEqual UnsupportedRequestEncodingRejection(HttpEncodings.gzip)
        }
      }

      "encodeRequest: tries to encode the request with the specified Encoder or rejects" in {
        import akka.http.scaladsl.coding._
        import HttpEncodings._

        Get("/") ~> route29 ~> check {
          response should haveContentEncoding(identity)
        }
        Get("/") ~> `Accept-Encoding`(gzip, deflate) ~> route29 ~> check {
          response should haveContentEncoding(gzip)
        }
        Get("/") ~> `Accept-Encoding`(deflate) ~> route29 ~> check {
          response should haveContentEncoding(deflate)
        }
        Get("/") ~> `Accept-Encoding`(identity) ~> route29 ~> check {
          response should haveContentEncoding(identity)
        }
      }

      "encodeRequestWith: tries to encode the request with the specified Encoder or rejects" in {
        import akka.http.scaladsl.coding._
        import HttpEncodings._

        Get("/") ~> route29a ~> check {
          response should haveContentEncoding(gzip)
        }
        Get("/") ~> `Accept-Encoding`() ~> route29a ~> check {
          rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)
        }
        Get("/") ~> `Accept-Encoding`(gzip, deflate) ~> route29a ~> check {
          response should haveContentEncoding(gzip)
        }
        Get("/") ~> `Accept-Encoding`(deflate) ~> route29a ~> check {
          rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)
        }
        Get("/") ~> `Accept-Encoding`(identity) ~> route29a ~> check {
          rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)
        }
      }

      "cookie: extracts a cookie with a given name from a request or otherwise rejects" in {
        Get("/") ~> route30 ~> check {
          rejection shouldEqual MissingCookieRejection("userName")
        }
        Get("/") ~> Route.seal(route30) ~> check {
          responseAs[String] shouldEqual "Request is missing required cookie 'userName'"
        }
      }

      "deleteCookie: adds a header to the response to request the removal of the cookie with the given name on the client" in {
        import akka.http.scaladsl.model.DateTime
        Get("/") ~> route31 ~> check {
          responseAs[String] shouldEqual "The user was logged out"
          header[`Set-Cookie`] shouldEqual Some(`Set-Cookie`(HttpCookie("userName", value = "deleted", expires = Some(DateTime.MinValue))))
        }
      }

      "optionalCookie: extracts an optional cookie with a given name from a request" in {
        Get("/") ~> Cookie("userName" -> "paul") ~> route32 ~> check {
          responseAs[String] shouldEqual "The logged in user is 'paul'"
        }
        Get("/") ~> route32 ~> check {
          responseAs[String] shouldEqual "No user logged in"
        }
      }

      "setCookie: adds a header to the response to request the update of the cookie with the given name on the client" in {
        Get("/") ~> route33 ~> check {
          responseAs[String] shouldEqual "The user was logged in"
          header[`Set-Cookie`] shouldEqual Some(`Set-Cookie`(HttpCookie("userName", value = "paul")))
        }
      }

      "logRequest: logs the request" in {
        import akka.http.scaladsl.server.Directives._
        Get("/") ~> logRequestPrintln(complete("logged")) ~> check {
          responseAs[String] shouldEqual "logged"
        }
      }

      "logRequestResult: logs request and response" in {
        import akka.http.scaladsl.server.Directives._
        Get("/") ~> logRequestResultPrintln(complete("logged")) ~> check {
          responseAs[String] shouldEqual "logged"
        }
      }

      "logResult: logs response" in {
        import akka.http.scaladsl.server.Directives._
        Get("/") ~> logResultPrintln(complete("logged")) ~> check {
          responseAs[String] shouldEqual "logged"
        }
      }

      "handleExceptions: catches exceptions thrown by the inner route and handles them" in {
        Get("/divide/10/0") ~> route34 ~> check {
          status shouldEqual StatusCodes.BadRequest
          responseAs[String] shouldEqual "You've got your arithmetic wrong, fool!"
        }
      }

      "handleRejections: handles rejections produced by the inner route and handles them" in {
        Get("/handled/existing") ~> route35 ~> check {
          responseAs[String] shouldEqual "This path exists"
        }
        Get("/missing") ~> Route.seal(route35) /* applies default handler */ ~> check {
          status shouldEqual StatusCodes.NotFound
          responseAs[String] shouldEqual "The requested resource could not be found."
        }
        Get("/handled/missing") ~> route35 ~> check {
          status shouldEqual StatusCodes.NotFound
          responseAs[String] shouldEqual "Oh man, what you are looking for is long gone."
        }
      }

    }

  }

}