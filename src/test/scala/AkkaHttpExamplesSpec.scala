import org.scalatest.{ WordSpecLike, Matchers }
import org.scalatest.prop.PropertyChecks
import org.scalatest.junit.JUnitRunner
import org.scalacheck._
import akka.http.scaladsl.testkit.ScalatestRouteTest
import akka.http.scaladsl.model.StatusCodes
import org.scalatest.matchers._

class AkkaHttpExamplesSpec extends WordSpecLike with Matchers with PropertyChecks with ScalatestRouteTest {

  implicit override val generatorDrivenConfig = PropertyCheckConfig(minSize = 1, maxSize = 100, minSuccessful = 100, workers = 5)

  import AkkaHttpExamples.http.incoming.highlevel.directives._
  import akka.http.scaladsl.server._
  import akka.http.scaladsl.model.headers._

  object CustomMatchers {

    import akka.http.scaladsl.model._

    class ContentEncodingMatcher(expectedEncoding: HttpEncoding) extends Matcher[HttpResponse] {
      def apply(left: HttpResponse) = {
        val encoding = left.encoding
        MatchResult(
          encoding == expectedEncoding,
          s"""Encoding $encoding is not $expectedEncoding""",
          s"""Encoding $encoding is $expectedEncoding"""
        )
      }
    }

    def haveContentEncoding(expectedEncoding: HttpEncoding) = new ContentEncodingMatcher(expectedEncoding)
  }

  import CustomMatchers._

  "An Akka Http" must {
    "provide directives" which {

      "cancelRejection: cancels rejection" in {
        Get("/") ~> route9 ~> check {
          rejections shouldEqual Nil
          handled shouldEqual false
        }
      }

      "cancelRejections: cancels rejections" in {
        Get("/") ~> route10 ~> check {
          rejections shouldEqual Nil
          handled shouldEqual false
        }
      }

      "extract: extracts value from the request context" in {
        Get("/abcdef") ~> route11 ~> check {
          responseAs[String] shouldEqual "The length of the request URI is 25"
        }
      }

      "extractRequest: extracts the complete HttpRequest instance" in {
        Post("/", "text") ~> route12 ~> check {
          responseAs[String] shouldEqual "Request method is POST and content-type is text/plain; charset=UTF-8"
        }
        Get("/") ~> route12 ~> check {
          responseAs[String] shouldEqual "Request method is GET and content-type is none/none"
        }
      }

      "extractUnmatchedPath: extracts the unmatched path from the request context" in {
        Get("/abc") ~> route13 ~> check {
          responseAs[String] shouldEqual "Unmatched: ''"
        }
        Get("/abc/456") ~> route13 ~> check {
          responseAs[String] shouldEqual "Unmatched: '/456'"
        }
      }

      "extractUri: accesses the full URI of the request" in {
        Get("/") ~> route14 ~> check {
          // tests are executed with the host assumed to be "example.com"
          responseAs[String] shouldEqual "Full URI: http://example.com/"
        }
        Get("/test") ~> route14 ~> check {
          responseAs[String] shouldEqual "Full URI: http://example.com/test"
        }
      }

      "mapInnerRoute: changes the execution model of the inner route by wrapping it with arbitrary logic" in {
        Get("/") ~> route15 ~> check {
          responseAs[String] shouldEqual "Got IllegalArgumentException 'BLIP! BLOP! Everything broke'"
        }
      }

      "mapRejections: transforms the list of rejections the inner route produced" in {
        Get("/") ~> route16 ~> check {
          rejection shouldEqual AuthorizationFailedRejection
        }
      }

      "mapRequest: transforms the request before it is handled by the inner route" in {
        Get("/") ~> route17 ~> check {
          responseAs[String] shouldEqual "The request method was POST"
        }
      }

      "mapRequestContext: transforms the RequestContext before it is passed to the inner route" in {
        Get("/abc/def/ghi") ~> route18 ~> check {
          responseAs[String] shouldEqual "POST"
        }
      }

      "mapResponse: changes the response that was generated by the inner route" in {
        Get("/abcdef?ghi=12") ~> route19 ~> check {
          status shouldEqual StatusCodes.BadGateway
        }
      }

      "mapResponseEntity: changes the response entity that was generated by the inner route" in {
        Get("/") ~> route20 ~> check {
          responseAs[String] shouldEqual "testabc"
        }
      }

      "mapResponseHeaders: changes the list of response headers that was generated by the inner route" in {
        Get("/") ~> RawHeader("id", "12345") ~> RawHeader("id2", "67890") ~> route21 ~> check {
          header("id") shouldEqual None
          header("id2").get.value shouldEqual "67890"
        }
      }

      "mapRouteResultPF: changes the message the inner route sends to the responder" in {
        Get("/") ~> route22 ~> check {
          rejection shouldEqual AuthorizationFailedRejection
        }
      }

      "mapUnmatchedPath: transforms the unmatchedPath field of the request context for inner routes" in {
        Get("/123/abc") ~> route23 ~> check {
          responseAs[String] shouldEqual "Content"
        }
        Get("/123456/abc") ~> route23 ~> check {
          responseAs[String] shouldEqual "Content"
        }
      }

      "provide: passes the request unchanged to its inner route" in {
        Get("/") ~> route24 ~> check {
          responseAs[String] shouldEqual "prefix:test"
        }
      }

      "textract: calculates a tuple of values from the request context and provides them to the inner route" in {
        Get("/abcdef?ghi=12") ~> route25 ~> check {
          responseAs[String] shouldEqual "The path is /abcdef and the query is ghi=12"
        }
      }

      "tprovide: provides a tuple of values to the inner route" in {
        Get("/") ~> route26 ~> check {
          responseAs[String] shouldEqual "Value is test and its length is 4"
        }
      }

      "conditional: provides a tuple of values to the inner route" in {
        Get("/") ~> RawHeader("ETag", "aaa") ~> route27 ~> check {
          status === StatusCodes.NotModified
        }
        Get("/") ~> route27 ~> check {
          status === StatusCodes.OK
        }
      }

      "decodeRequest: tries to decode the request with the specified Decoder or rejects" in {
        import akka.http.scaladsl.coding._
        val helloGzipped = Gzip.encode(akka.util.ByteString("Hello"));
        val helloDeflated = Deflate.encode(akka.util.ByteString("Hello"));

        Post("/", helloGzipped) ~> `Content-Encoding`(HttpEncodings.gzip) ~> route28 ~> check {
          responseAs[String] shouldEqual "Request content: 'Hello'"
        }
        Post("/", helloDeflated) ~> `Content-Encoding`(HttpEncodings.deflate) ~> route28 ~> check {
          responseAs[String] shouldEqual "Request content: 'Hello'"
        }
        Post("/", "hello uncompressed") ~> `Content-Encoding`(HttpEncodings.identity) ~> route28 ~> check {
          responseAs[String] shouldEqual "Request content: 'hello uncompressed'"
        }
      }

      "decodeRequestWith: tries to decode the request with the specified Decoder or rejects" in {
        import akka.http.scaladsl.coding._
        val helloGzipped = Gzip.encode(akka.util.ByteString("Hello"));
        val helloDeflated = Deflate.encode(akka.util.ByteString("Hello"));

        Post("/", helloGzipped) ~> `Content-Encoding`(HttpEncodings.gzip) ~> route28a ~> check {
          responseAs[String] shouldEqual "Request content: 'Hello'"
        }
        Post("/", helloDeflated) ~> `Content-Encoding`(HttpEncodings.deflate) ~> route28a ~> check {
          rejection shouldEqual UnsupportedRequestEncodingRejection(HttpEncodings.gzip)
        }
        Post("/", "hello") ~> `Content-Encoding`(HttpEncodings.identity) ~> route28a ~> check {
          rejection shouldEqual UnsupportedRequestEncodingRejection(HttpEncodings.gzip)
        }
      }

      "encodeRequest: tries to encode the request with the specified Encoder or rejects" in {
        import akka.http.scaladsl.coding._
        import HttpEncodings._

        Get("/") ~> route29 ~> check {
          response should haveContentEncoding(identity)
        }
        Get("/") ~> `Accept-Encoding`(gzip, deflate) ~> route29 ~> check {
          response should haveContentEncoding(gzip)
        }
        Get("/") ~> `Accept-Encoding`(deflate) ~> route29 ~> check {
          response should haveContentEncoding(deflate)
        }
        Get("/") ~> `Accept-Encoding`(identity) ~> route29 ~> check {
          response should haveContentEncoding(identity)
        }
      }

      "encodeRequestWith: tries to encode the request with the specified Encoder or rejects" in {
        import akka.http.scaladsl.coding._
        import HttpEncodings._

        Get("/") ~> route29a ~> check {
          response should haveContentEncoding(gzip)
        }
        Get("/") ~> `Accept-Encoding`() ~> route29a ~> check {
          rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)
        }
        Get("/") ~> `Accept-Encoding`(gzip, deflate) ~> route29a ~> check {
          response should haveContentEncoding(gzip)
        }
        Get("/") ~> `Accept-Encoding`(deflate) ~> route29a ~> check {
          rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)
        }
        Get("/") ~> `Accept-Encoding`(identity) ~> route29a ~> check {
          rejection shouldEqual UnacceptedResponseEncodingRejection(gzip)
        }
      }

      "cookie: extracts a cookie with a given name from a request or otherwise rejects" in {
        Get("/") ~> route30 ~> check {
          rejection shouldEqual MissingCookieRejection("userName")
        }
        Get("/") ~> Route.seal(route30) ~> check {
          responseAs[String] shouldEqual "Request is missing required cookie 'userName'"
        }
      }

      "deleteCookie: adds a header to the response to request the removal of the cookie with the given name on the client" in {
        import akka.http.scaladsl.model.DateTime
        Get("/") ~> route31 ~> check {
          responseAs[String] shouldEqual "The user was logged out"
          header[`Set-Cookie`] shouldEqual Some(`Set-Cookie`(HttpCookie("userName", value = "deleted", expires = Some(DateTime.MinValue))))
        }
      }

      "optionalCookie: extracts an optional cookie with a given name from a request" in {
        Get("/") ~> Cookie("userName" -> "paul") ~> route32 ~> check {
          responseAs[String] shouldEqual "The logged in user is 'paul'"
        }
        Get("/") ~> route32 ~> check {
          responseAs[String] shouldEqual "No user logged in"
        }
      }

      "setCookie: adds a header to the response to request the update of the cookie with the given name on the client" in {
        Get("/") ~> route33 ~> check {
          responseAs[String] shouldEqual "The user was logged in"
          header[`Set-Cookie`] shouldEqual Some(`Set-Cookie`(HttpCookie("userName", value = "paul")))
        }
      }

      "logRequest: logs the request" in {
        import akka.http.scaladsl.server.Directives._
        Get("/") ~> logRequestPrintln(complete("logged")) ~> check {
          responseAs[String] shouldEqual "logged"
        }
      }

      "logRequestResult: logs request and response" in {
        import akka.http.scaladsl.server.Directives._
        Get("/") ~> logRequestResultPrintln(complete("logged")) ~> check {
          responseAs[String] shouldEqual "logged"
        }
      }

      "logResult: logs response" in {
        import akka.http.scaladsl.server.Directives._
        Get("/") ~> logResultPrintln(complete("logged")) ~> check {
          responseAs[String] shouldEqual "logged"
        }
      }

      "handleExceptions: catches exceptions thrown by the inner route and handles them" in {
        Get("/divide/10/0") ~> route34 ~> check {
          status shouldEqual StatusCodes.BadRequest
          responseAs[String] shouldEqual "You've got your arithmetic wrong, fool!"
        }
      }

      "handleRejections: handles rejections produced by the inner route and handles them" in {
        Get("/handled/existing") ~> route35 ~> check {
          responseAs[String] shouldEqual "This path exists"
        }
        Get("/missing") ~> Route.seal(route35) /* applies default handler */ ~> check {
          status shouldEqual StatusCodes.NotFound
          responseAs[String] shouldEqual "The requested resource could not be found."
        }
        Get("/handled/missing") ~> route35 ~> check {
          status shouldEqual StatusCodes.NotFound
          responseAs[String] shouldEqual "Oh man, what you are looking for is long gone."
        }
      }

      "formFields: extracts fields from POST requests generated by HTML forms" in {
        import akka.http.scaladsl.model._
        Post("/", FormData("color" -> "blue", "age" -> "68")) ~> route36 ~> check {
          responseAs[String] shouldEqual "The color is 'blue' and the age ten years ago was 58"
        }
        Get("/") ~> Route.seal(route36) ~> check {
          status shouldEqual StatusCodes.BadRequest
          responseAs[String] shouldEqual "Request is missing required form field 'color'"
        }
        Post("/color", FormData("red" -> "12", "green" -> "35", "blue" -> "234")) ~> route37 ~> check {
          responseAs[String] shouldEqual "RGB(12,35,234)"
        }
      }

      "onComplete: evaluates its parameter of type Future[T], and once the Future has been completed, extracts its result as a value " in {
        Get("/divide/10/2") ~> route38 ~> check {
          responseAs[String] shouldEqual "The result was 5"
        }

        Get("/divide/10/0") ~> Route.seal(route38) ~> check {
          status shouldEqual StatusCodes.InternalServerError
          responseAs[String] shouldEqual "An error occurred: / by zero"
        }
      }

      "onSuccess: evaluates its parameter of type Future[T], and once the Future has been completed successfully, extracts its result as a value " in {
        Get("/success") ~> route39 ~> check {
          responseAs[String] shouldEqual "Ok"
        }

        Get("/failure") ~> Route.seal(route39) ~> check {
          status shouldEqual StatusCodes.InternalServerError
          responseAs[String] shouldEqual "There was an internal server error."
        }
      }

      "completeOrRecoverWith: completes the request with the result of the computation given as argument of type Future[T]" in {
        Get("/success") ~> route40 ~> check {
          responseAs[String] shouldEqual "Ok"
        }

        Get("/failure") ~> Route.seal(route40) ~> check {
          status shouldEqual StatusCodes.InternalServerError
          responseAs[String] shouldEqual "There was an internal server error."
        }
      }

      "headerValue: traverses the list of request headers with the specified function and extracts the first value the function returns" in {
        Get("/") ~> Host("example.com", 5043) ~> route41 ~> check {
          responseAs[String] shouldEqual "The port was 5043"
        }
        Get("/") ~> Route.seal(route41) ~> check {
          status shouldEqual StatusCodes.NotFound
          responseAs[String] shouldEqual "The requested resource could not be found."
        }
      }

      "headerValueByName: extracts the value of the HTTP request header with the given name." in {
        Get("/") ~> RawHeader("X-User-Id", "Joe42") ~> route42 ~> check {
          responseAs[String] shouldEqual "The user is Joe42"
        }

        Get("/") ~> Route.seal(route42) ~> check {
          status shouldEqual StatusCodes.BadRequest
          responseAs[String] shouldEqual "Request is missing required HTTP header 'X-User-Id'"
        }
      }

      "headerValueByType: traverses the list of request headers and extracts the first header of the given type" in {
        val originHeader = Origin(HttpOrigin("http://localhost:8080"))
        // extract a header if the type is matching
        Get("abc") ~> originHeader ~> route43 ~> check {
          responseAs[String] shouldEqual "The first origin was http://localhost:8080"
        }
        // reject a request if no header of the given type is present
        /*Get("abc") ~> route43 ~> check {
          inside(rejection) { case MissingHeaderRejection("Origin") ⇒ }
        }*/
      }

      "headerValuePF: calls the specified partial function with the first request header the function is defined at" in {
        Get("/") ~> Host("example.com", 5043) ~> route44 ~> check {
          responseAs[String] shouldEqual "The port was 5043"
        }
        Get("/") ~> Route.seal(route44) ~> check {
          status shouldEqual StatusCodes.NotFound
          responseAs[String] shouldEqual "The requested resource could not be found."
        }
      }

      "optionalHeaderValue: traverses the list of request headers with the specified function and extracts the first value the function returns as Some(value)" in {
        Get("/") ~> Host("example.com", 5043) ~> route45 ~> check {
          responseAs[String] shouldEqual "The port was Some(5043)"
        }
        Get("/") ~> Route.seal(route45) ~> check {
          responseAs[String] shouldEqual "The port was None"
        }
      }

      "extractHost: extracts the hostname part of the Host header value in the request." in {
        Get() ~> Host("company.com", 9090) ~> route46 ~> check {
          status shouldEqual StatusCodes.OK
          responseAs[String] shouldEqual "Hostname: company.com"
        }
      }

      "host: filters requests matching conditions against the hostname part of the Host header value in the request." in {
        Get() ~> Host("rest.company.com") ~> route47 ~> check {
          status shouldEqual StatusCodes.OK
          responseAs[String] shouldEqual "Ok"
        }

        Get() ~> Host("notallowed.company.com") ~> route47 ~> check {
          handled shouldBe false
        }
      }

      "completeWith: uses the marshaller for a given type to produce a completion function that is passed to its inner route." in {
        import akka.http.scaladsl.model._
        Get("/") ~> route48 ~> check {
          mediaType shouldEqual MediaTypes.`application/json`
          responseAs[String] should include(""""name": "Jane"""")
          responseAs[String] should include(""""favoriteNumber": 42""")
        }
      }

      "entity: unmarshalls the request entity to the given type and passes it to its inner route" in {
        import akka.http.scaladsl.model._
        Post("/", HttpEntity(MediaTypes.`application/json`, """{ "name": "Jane", "favoriteNumber" : 42 }""")) ~>
          route49 ~> check {
            responseAs[String] shouldEqual "Person: Jane - favorite number: 42"
          }
      }

      "handleWith: completes the request using the given function" in {
        import akka.http.scaladsl.model._
        Post("/", HttpEntity(MediaTypes.`application/json`, """{ "name": "Jane", "favoriteNumber" : 42 }""")) ~>
          route50 ~> check {
            mediaType shouldEqual MediaTypes.`application/json`
            responseAs[String] should include(""""name": "Jane"""")
            responseAs[String] should include(""""favoriteNumber": 42""")
          }
      }

      "delete: matches requests with HTTP method DELETE" in {
        Delete("/") ~> route51 ~> check {
          responseAs[String] shouldEqual "This is a DELETE request."
        }
      }

      "get: matches requests with HTTP method GET" in {
        Get("/") ~> route52 ~> check {
          responseAs[String] shouldEqual "This is a GET request."
        }
      }

      "method: matches HTTP requests based on their method" in {
        Get("/") ~> Route.seal(route53) ~> check {
          status shouldEqual StatusCodes.MethodNotAllowed
          responseAs[String] shouldEqual "HTTP method not allowed, supported methods: PUT"
        }
      }

      "extractClientIP: provides the value of X-Forwarded-For, Remote-Address, or X-Real-IP headers" in {
        import akka.http.scaladsl.model._
        Get("/").withHeaders(`Remote-Address`(RemoteAddress("192.168.3.12"))) ~> route54 ~> check {
          responseAs[String] shouldEqual "Client's ip is 192.168.3.12"
        }
      }

      "rejectEmptyResponse: replaces a response with no content with an empty rejection" in {
        Get("/even/23") ~> Route.seal(route55) ~> check {
          status shouldEqual StatusCodes.NotFound
        }
        Get("/even/28") ~> route55 ~> check {
          responseAs[String] shouldEqual "Number 28 is even."
        }
      }

      "requestEntityEmpty: filter that checks if the request entity is empty and only then passes processing to the inner route" in {
        Post("/", "text") ~> Route.seal(route56) ~> check {
          responseAs[String] shouldEqual "request entity present"
        }
        Post("/") ~> route56 ~> check {
          responseAs[String] shouldEqual "request entity empty"
        }
      }

      "validate: checks an arbitrary condition and passes control to the inner route if it returns true" in {
        Get("/234") ~> route57 ~> check {
          responseAs[String] shouldEqual "Full URI: http://example.com/234"
        }
        Get("/abcdefghijkl") ~> route57 ~> check {
          rejection shouldEqual ValidationRejection("Path too long: '/abcdefghijkl'", None)
        }
      }

      "parameters: the parameters directive filters on the existence of several query parameters and extract their values." in {
        Get("/?color=blue&backgroundColor=red") ~> route58 ~> check {
          responseAs[String] === "The color is 'blue' and the background is 'red'"
        }
        Get("/?color=blue") ~> Route.seal(route58) ~> check {
          status === StatusCodes.NotFound
          responseAs[String] === "Request is missing required query parameter 'backgroundColor'"
        }
        Get("/?color=blue&backgroundColor=red") ~> route58a ~> check {
          responseAs[String] === "The color is 'blue' and the background is 'red'"
        }
        Get("/?color=blue") ~> route58a ~> check {
          responseAs[String] === "The color is 'blue' and the background is '<undefined>'"
        }
        Get("/?color=blue&backgroundColor=red") ~> route58b ~> check {
          responseAs[String] === "The color is 'blue' and the background is 'red'"
        }
        Get("/?color=blue") ~> route58b ~> check {
          responseAs[String] === "The color is 'blue' and the background is 'white'"
        }
        Get("/?color=blue&backgroundColor=red") ~> route58c ~> check {
          responseAs[String] === "The color is 'blue' and the background is 'red'"
        }
        Get("/?color=blue") ~> route58c ~> check {
          responseAs[String] === "The color is 'blue' and the background is 'white'"
        }
        Get("/?color=blue&count=42") ~> route58d ~> check {
          responseAs[String] === "The color is 'blue' and you have 42 of it."
        }

        Get("/?color=blue&count=blub") ~> Route.seal(route58d) ~> check {
          status === StatusCodes.BadRequest
          responseAs[String] === "The query parameter 'count' was malformed:\n'blub' is not a valid 32-bit integer value"
        }
      }

      "parameterMap: extracts all parameters at once as a Map[String, String]" in {
        Get("/?color=blue&count=42") ~> route59 ~> check {
          responseAs[String] === "The parameters are color = 'blue', count = '42'"
        }
        Get("/?x=1&x=2") ~> route59 ~> check {
          responseAs[String] === "The parameters are x = '2'"
        }
      }

      "parameterMultiMap: extracts all parameters at once as a multi-map of type Map[String, List[String]" in {
        Get("/?color=blue&count=42") ~> route60 ~> check {
          responseAs[String] === "There are parameters color -> 1, count -> 1"
        }
        Get("/?x=23&x=42") ~> route60 ~> check {
          responseAs[String] === "There are parameters x -> 2"
        }
      }

      "parameterSeq: extracts all parameters at once in the original order as (name, value) tuples of type (String, String)" in {
        Get("/?color=blue&count=42") ~> route61 ~> check {
          responseAs[String] === "The parameters are color = 'blue', count = '42'"
        }
        Get("/?x=1&x=2") ~> route61 ~> check {
          responseAs[String] === "The parameters are x = '1', x = '2'"
        }
      }

      "path: matches the complete unmatched path" in {
        Get("/") ~> route62 ~> check {
          handled shouldEqual false
        }

        Get("/foo") ~> route62 ~> check {
          responseAs[String] shouldEqual "/foo"
        }

        Get("/foo/bar") ~> route62 ~> check {
          responseAs[String] shouldEqual "/foo/bar"
        }

        Get("/ball/1337") ~> route62 ~> check {
          responseAs[String] shouldEqual "odd ball"
        }
      }

      "pathEnd: only passes the request to its inner route if the unmatched path is empty" in {
        Get("/foo") ~> route63 ~> check {
          responseAs[String] shouldEqual "/foo"
        }

        Get("/foo/") ~> route63 ~> check {
          handled shouldEqual false
        }

        Get("/foo/bar") ~> route63 ~> check {
          responseAs[String] shouldEqual "/foo/bar"
        }
      }

      "pathEndOrSingleSlash: only passes the request to its inner route if the unmatched path is either empty or contains only one single slash." in {
        Get("/foo") ~> route64 ~> check {
          responseAs[String] shouldEqual "/foo"
        }

        Get("/foo/") ~> route64 ~> check {
          responseAs[String] shouldEqual "/foo"
        }

        Get("/foo/bar") ~> route64 ~> check {
          responseAs[String] shouldEqual "/foo/bar"
        }
      }

      "pathPrefix: matches and consumes a prefix of the unmatched path " in {
        Get("/") ~> route65 ~> check {
          handled shouldEqual false
        }

        Get("/ball") ~> route65 ~> check {
          responseAs[String] shouldEqual "/ball"
        }

        Get("/ball/1337") ~> route65 ~> check {
          responseAs[String] shouldEqual "odd ball"
        }
      }

      "pathPrefixTest: potentially extracts one or more values (depending on the type of the argument) but doesn't consume its match from the unmatched path" in {
        Get("/foo/doo") ~> route66 ~> check {
          responseAs[String] shouldEqual "/doo"
        }

        Get("/bar/yes") ~> route66 ~> check {
          responseAs[String] shouldEqual "/yes"
        }
      }

      "pathSingleSlash: only passes the request to its inner route if the unmatched path of the RequestContext contains exactly one single slash" in {
        Get("/") ~> route67 ~> check {
          responseAs[String] shouldEqual "root"
        }

        Get("/ball") ~> route67 ~> check {
          handled shouldEqual false
        }

        Get("/ball/") ~> route67 ~> check {
          responseAs[String] shouldEqual "/ball/"
        }

        Get("/ball/1337") ~> route67 ~> check {
          responseAs[String] shouldEqual "odd ball"
        }
      }

      "pathSuffix: matches and consumes a suffix of the unmatched path" in {
        Get("/start/middle/end") ~> route68 ~> check {
          responseAs[String] shouldEqual "/middle/"
        }

        Get("/start/something/barbaz/foo") ~> route68 ~> check {
          responseAs[String] shouldEqual "/something/"
        }
      }

      "rawPathPrefix: matches and consumes a prefix of the unmatched path, does not automatically add a leading slash" in {
        Get("/foobar/baz") ~> route69 ~> check {
          responseAs[String] shouldEqual "/baz"
        }

        Get("/foodoo/baz") ~> route69 ~> check {
          responseAs[String] shouldEqual "/baz"
        }
      }

    }

  }

}